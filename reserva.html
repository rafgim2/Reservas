<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RESERVA DE PORT√ÅTILES</title>
  <style>
    :root {
      --col-date-width: 110px;
      --col-session-width: 90px;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
    }

    .top-bar {
      position: sticky;
      top: 0;
      z-index: 50;
      background: #f5f5f5;
    }

    header {
      background: #1f4e79;
      color: white;
      padding: 16px 24px 10px;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: 24px;
      letter-spacing: 1px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      padding: 8px 24px 6px;
      background: #f5f5f5;
    }

    main {
      padding: 12px 16px 24px;
    }

    label {
      font-weight: 600;
    }

    select {
      padding: 4px 8px;
      font-size: 14px;
    }

    .legend {
      font-size: 12px;
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      border: 1px solid #aaa;
    }

    .legend-color.free {
      background: #ffffff;
    }

    .legend-color.reserved {
      background: #e53935;
    }

    .table-container {
      max-width: 100%;
      overflow: auto;
      border: 1px solid #ccc;
      background: white;
      border-radius: 4px;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      min-width: 900px;
      font-size: 12px;
      table-layout: fixed;
    }

    thead {
      background: #e1e9f2;
    }

    thead th {
      position: sticky;
      top: 0;
      z-index: 10;
      background: #dde3ff;
      border: 1px solid #ccc;
      padding: 4px 6px;
      text-align: center;
      white-space: normal;
      word-break: break-word;
    }

    th,
    td {
      border: 1px solid #ccc;
      padding: 4px 6px;
      text-align: center;
      white-space: normal;
      word-break: break-word;
      background: #ffffff; /* Todo libre en blanco por defecto */
    }

    thead th:nth-child(1),
    tbody td:nth-child(1) {
      width: var(--col-date-width);
      min-width: var(--col-date-width);
      max-width: var(--col-date-width);
    }

    thead th:nth-child(2),
    tbody td:nth-child(2) {
      width: var(--col-session-width);
      min-width: var(--col-session-width);
      max-width: var(--col-session-width);
    }

    thead th:nth-child(1) {
      position: sticky;
      left: 0;
      z-index: 11;
      background: #dde3ff;
    }

    thead th:nth-child(2) {
      position: sticky;
      left: var(--col-date-width);
      z-index: 11;
      background: #dde3ff;
    }

    tbody td:nth-child(1) {
      position: sticky;
      left: 0;
      z-index: 11;
      background: #fff;
    }

    tbody td:nth-child(2) {
      position: sticky;
      left: var(--col-date-width);
      z-index: 11;
      background: #fff;
    }

    /* Separador grueso entre d√≠as (primera fila de cada d√≠a) */
    tbody tr.first-slot-of-day td {
      border-top-width: 3px;
    }

    /* Fila con alguna reserva (fondo rojo clarito) */
    tbody tr.row-has-reservation td {
      background: #ffebee;
    }

    td.reservable {
      cursor: pointer;
      transition: background 0.15s ease, color 0.15s ease;
      position: relative;
      overflow: hidden;
    }

    td.reservable:hover {
      box-shadow: inset 0 0 0 2px #1f4e79;
    }

    td.reserved {
      background: #e53935 !important;
      color: #ffffff;
      font-weight: 700;
    }

    /* Reservas fijas del horario (no clicables) */
    td.fixed-reserved {
      background: #b71c1c !important;
      color: #ffffff;
      font-weight: 700;
      cursor: default;
    }

    td.reservable::before {
      content: attr(data-class);
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 10px;
      color: rgba(0, 0, 0, 0.25);
      pointer-events: none;
      text-align: center;
      width: 100%;
      padding: 0 4px;
      box-sizing: border-box;
      line-height: 1.2;
    }

    td.reserved::before {
      color: rgba(255, 255, 255, 0.6);
    }

    td.fixed-reserved::before {
      color: rgba(255, 255, 255, 0.7);
    }

    .info {
      font-size: 11px;
      color: #555;
      margin-top: 6px;
    }
  </style>
</head>
<body>
  <!-- Barra superior fija -->
  <div class="top-bar">
    <header>
      <h1>RESERVA DE PORT√ÅTILES</h1>
    </header>

    <div class="controls">
      <div>
        <label for="monthSelect">Mes:</label>
        <select id="monthSelect"></select>
      </div>
      <div class="legend">
        <span class="legend-item">
          <span class="legend-color free"></span> Libre
        </span>
        <span class="legend-item">
          <span class="legend-color reserved"></span> Reservado
        </span>
        <span>Haz doble clic o doble toque para reservar / liberar.</span>
      </div>
    </div>
  </div>

  <main>
    <div class="table-container">
      <table id="calendarTable">
        <!-- Cabecera y cuerpo se generan por JS -->
      </table>
    </div>

    <p class="info">
      * Las reservas pueden cambiarse o cancelarse durante un m√°ximo de 2 minutos desde el momento en que se realizan.
    </p>
    <p class="info">
      * En cada periodo de 24 horas solo se puede realizar una reserva por semana.
    </p>
  </main>

  <!-- JS con Firestore -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import {
      getFirestore,
      doc,
      onSnapshot,
      setDoc,
      deleteField
    } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";

    // ‚è± TIEMPO M√ÅXIMO PARA DESHACER (ms) ‚Üí ahora 2 minutos
    const UNRESERVE_WINDOW_MS = 2 * 60 * 1000;

    // ‚è± TIEMPO M√ÅXIMO DE BLOQUEO POR DISPOSITIVO (24h)
    const USER_RESERVATION_TTL_MS = 24 * 60 * 60 * 1000;

    const firebaseConfig = {
      apiKey: "AIzaSyD5EAMg-0p54f8bPq8SVdZ_ePg5Xso3cmg",
      authDomain: "arm1-acbba.firebaseapp.com",
      projectId: "arm1-acbba",
      storageBucket: "arm1-acbba.firebasestorage.app",
      messagingSenderId: "408825932019",
      appId: "1:408825932019:web:10f2079b590b4c9ca3af86",
      measurementId: "G-S78TM6PVRL"
    };

    const app = initializeApp(firebaseConfig);
    const db  = getFirestore(app);

    const months = [
      { year: 2025, month: 11, name: "Noviembre 2025" },
      { year: 2025, month: 12, name: "Diciembre 2025" },
      { year: 2026, month: 1, name: "Enero 2026" },
      { year: 2026, month: 2, name: "Febrero 2026" },
      { year: 2026, month: 3, name: "Marzo 2026" },
      { year: 2026, month: 4, name: "Abril 2026" },
      { year: 2026, month: 5, name: "Mayo 2026" },
      { year: 2026, month: 6, name: "Junio 2026" }
    ];

    const classes = [
      "Infantil 3 a√±os",
      "Infantil 4 a√±os",
      "Infantil 5 a√±os",
      "1¬∫A",
      "2¬∫A",
      "3¬∫A",
      "4¬∫A",
      "4¬∫B",
      "5¬∫A",
      "5¬∫B",
      "6¬∫A",
      "6¬∫B"
    ];

    // Horarios normales (nov‚Äìmay)
    const defaultSlots = [
      "9:00-9:45",   // 1¬™
      "9:45-10:30",  // 2¬™
      "10:30-11:15", // 3¬™
      "11:45-12:30", // 4¬™
      "12:30-13:15", // 5¬™
      "13:15-14:00"  // 6¬™
    ];

    // Horarios especiales para JUNIO 2026 (solo 5 sesiones)
    const juneSlots = [
      "9:00-9:40",
      "9:40-10:20",
      "10:20-11:00",
      "11:30-12:15",
      "12:15-13:00"
    ];

    function getSlotsForMonth(monthIndex) {
      const { year, month } = months[monthIndex];
      if (year === 2026 && month === 6) {
        // En junio solo hay 5 sesiones, as√≠ que las reservas de la 6¬™ hora
        // del horario fijo se ignoran autom√°ticamente.
        return juneSlots;
      }
      return defaultSlots;
    }

    /* === RESERVAS FIJAS SEG√öN LA FOTO DEL HORARIO ===
       weekday: 1=Lunes ... 5=Viernes
       session: 1=1¬™, 2=2¬™,... 6=6¬™
    */
    const FIXED_WEEKLY_RESERVATIONS = [
      { weekday: 5, session: 1, className: "3¬∫A" }, // 1¬™ Viernes 3A
      { weekday: 4, session: 4, className: "5¬∫A" }, // 4¬™ Jueves 5A
      { weekday: 5, session: 4, className: "1¬∫A" }, // 4¬™ Viernes 1A
      { weekday: 4, session: 5, className: "4¬∫A" }, // 5¬™ Jueves 4A
      { weekday: 3, session: 6, className: "6¬∫B" }, // 6¬™ Mi√©rcoles 6B
      { weekday: 4, session: 6, className: "6¬∫A" }, // 6¬™ Jueves 6A
      { weekday: 5, session: 6, className: "5¬∫B" }  // 6¬™ Viernes 5B
    ];

    function isFixedReservation(dateIso, slot, className) {
      const d = new Date(dateIso);
      const weekday = d.getDay(); // 0=Dom,1=Lun,‚Ä¶,5=Vie
      if (weekday < 1 || weekday > 5) return false;

      const slotsForMonth = getSlotsForMonth(currentMonthIndex);
      const idx = slotsForMonth.indexOf(slot);
      if (idx === -1) return false;
      const session = idx + 1;

      return FIXED_WEEKLY_RESERVATIONS.some(
        r => r.weekday === weekday && r.session === session && r.className === className
      );
    }

    // Devuelve si una franja (fecha+slot) est√° ocupada por una reserva fija, aunque sea otra clase
    function getFixedReservationForSlot(dateIso, slot) {
      const d = new Date(dateIso);
      const weekday = d.getDay();
      if (weekday < 1 || weekday > 5) return null;

      const slotsForMonth = getSlotsForMonth(currentMonthIndex);
      const idx = slotsForMonth.indexOf(slot);
      if (idx === -1) return null;
      const session = idx + 1;

      const r = FIXED_WEEKLY_RESERVATIONS.find(
        x => x.weekday === weekday && x.session === session
      );
      return r || null;
    }

    const monthSelect    = document.getElementById("monthSelect");
    const calendarTable  = document.getElementById("calendarTable");

    let currentMonthIndex = 0;
    let currentData = {};
    let unsubscribe = null;

    function getCurrentDocId() {
      const { year, month } = months[currentMonthIndex];
      return `${year}-${String(month).padStart(2, "0")}`;
    }

    function monthDocRef(monthIndex) {
      const { year, month } = months[monthIndex];
      const id = `${year}-${String(month).padStart(2, "0")}`;
      return doc(db, "reservas_portatiles_celdas", id);
    }

    function buildReservationId(dateIso, slot, className) {
      return `${dateIso}__${slot}__${className}`;
    }

    function subscribeToMonth(monthIndex) {
      if (unsubscribe) {
        unsubscribe();
        unsubscribe = null;
      }
      currentMonthIndex = monthIndex;

      const ref = monthDocRef(monthIndex);
      unsubscribe = onSnapshot(ref, (snap) => {
        currentData = snap.exists() ? snap.data() : {};
        renderMonth(monthIndex);
      });
    }

    async function setReservationValue(id, value) {
      const ref = monthDocRef(currentMonthIndex);
      const update = {};
      update[id] = value;
      await setDoc(ref, update, { merge: true });
    }

    async function clearReservation(id) {
      const ref = monthDocRef(currentMonthIndex);
      const update = {};
      update[id] = deleteField();
      await setDoc(ref, update, { merge: true });
    }

    // ‚ûú CONTROL POR USUARIO:
    // M√°x. 1 reserva POR SEMANA (semana ISO) en las √∫ltimas 24h
    // Se guardan en localStorage por semana: { "2025-W45": { fullId, time }, ... }
    const LOCAL_USER_RES_KEY = "reservas_portatiles_mis_reservas_por_semana";

    // Calcula la semana ISO (a√±o-semana) a partir de una fecha YYYY-MM-DD
    function getWeekKeyFromIso(dateIso) {
      const [year, month, day] = dateIso.split("-").map(Number);
      const date = new Date(year, month - 1, day);
      const { isoYear, week } = getISOYearWeek(date);
      return `${isoYear}-W${String(week).padStart(2, "0")}`;
    }

    // Devuelve { isoYear, week } usando semanas ISO (lunes-domingo)
    function getISOYearWeek(date) {
      const tmp = new Date(date.valueOf());
      // D√≠a de la semana con lunes = 0
      const dayNr = (tmp.getDay() + 6) % 7;
      // Colocamos la fecha en el jueves de esa semana
      tmp.setDate(tmp.getDate() - dayNr + 3);

      const isoYear = tmp.getFullYear();

      // Jueves de la primera semana del a√±o ISO
      const jan4 = new Date(isoYear, 0, 4);
      const jan4Day = (jan4.getDay() + 6) % 7;
      jan4.setDate(jan4.getDate() - jan4Day + 3);

      const week = 1 + Math.round((tmp - jan4) / 604800000); // 604800000 = ms en una semana
      return { isoYear, week };
    }

    // Lee el mapa de reservas por semana del usuario desde localStorage
    function getUserReservationsMap() {
      try {
        const raw = localStorage.getItem(LOCAL_USER_RES_KEY);
        if (!raw) return {};
        const obj = JSON.parse(raw);
        if (!obj || typeof obj !== "object" || Array.isArray(obj)) return {};
        return obj;
      } catch {
        return {};
      }
    }

    // Guarda el mapa de reservas por semana
    function saveUserReservationsMap(map) {
      try {
        localStorage.setItem(LOCAL_USER_RES_KEY, JSON.stringify(map));
      } catch {
        // si falla localStorage, no pasa nada
      }
    }

    // Devuelve la reserva (si existe y no ha caducado) para una semana concreta
    function getUserReservationInfoForWeek(weekKey) {
      const map = getUserReservationsMap();
      const now = Date.now();
      let changed = false;

      // Limpiamos reservas caducadas (> 24h)
      for (const wk in map) {
        const info = map[wk];
        if (!info || typeof info.time !== "number") {
          delete map[wk];
          changed = true;
          continue;
        }
        if (now - info.time > USER_RESERVATION_TTL_MS) {
          delete map[wk];
          changed = true;
        }
      }

      if (changed) {
        saveUserReservationsMap(map);
      }

      return map[weekKey] || null;
    }

    // A√±ade/actualiza la reserva de una semana
    function addUserReservationForWeek(weekKey, fullId, time) {
      const map = getUserReservationsMap();
      map[weekKey] = { fullId, time };
      saveUserReservationsMap(map);
    }

    // Elimina del mapa cualquier reserva que tenga ese fullId
    function removeUserReservationByFullId(fullId) {
      const map = getUserReservationsMap();
      let changed = false;
      for (const wk in map) {
        if (map[wk] && map[wk].fullId === fullId) {
          delete map[wk];
          changed = true;
        }
      }
      if (changed) {
        saveUserReservationsMap(map);
      }
    }

    function buildFullReservationId(id) {
      const docId = getCurrentDocId();
      return `${docId}::${id}`;
    }

    // Devuelve la reserva (si existe) para una fecha + franja, sin importar la clase
    function getExistingReservationForSlot(dateIso, slot) {
      const prefix = `${dateIso}__${slot}__`;

      for (const key in currentData) {
        const value = currentData[key];
        if (!value) continue; // sin reserva

        if (typeof value === "number" || value === true) {
          if (key.startsWith(prefix)) {
            const parts = key.split("__");
            const cls   = parts[2] || "";
            return {
              id: key,
              className: cls,
              value
            };
          }
        }
      }

      // Si no hay en Firestore, miramos si la franja est√° ocupada por una reserva fija
      const fixed = getFixedReservationForSlot(dateIso, slot);
      if (fixed) {
        return {
          id: null,
          className: fixed.className,
          value: "fixed"
        };
      }

      return null;
    }

    // Selector de meses
    months.forEach((m, index) => {
      const opt = document.createElement("option");
      opt.value = index;
      opt.textContent = m.name;
      monthSelect.appendChild(opt);
    });

    monthSelect.addEventListener("change", () => {
      const idx = parseInt(monthSelect.value, 10);
      subscribeToMonth(idx);
    });

    // Obtener d√≠as lectivos (con inicial del d√≠a: L, M, X, J, V)
    function getWeekdays(year, month) {
      const days = [];
      const date = new Date(year, month - 1, 1);
      const initials = {
        1: "L",
        2: "M",
        3: "X",
        4: "J",
        5: "V"
      };

      while (date.getMonth() === month - 1) {
        const day = date.getDay(); // 0=Dom, 1=Lun,...,6=Sab
        if (day >= 1 && day <= 5) {
          const d = String(date.getDate()).padStart(2, "0");
          const m = String(month).padStart(2, "0");
          const y = year;
          const initial = initials[day] || "";
          days.push({
            iso: `${y}-${m}-${d}`,
            label: `${initial} ${d}/${m}/${y}`
          });
        }
        date.setDate(date.getDate() + 1);
      }
      return days;
    }

    function renderMonth(monthIndex) {
      const { year, month } = months[monthIndex];
      const days = getWeekdays(year, month);
      const slotsForMonth = getSlotsForMonth(monthIndex);
      const saved = currentData || {};

      calendarTable.innerHTML = "";

      // CABECERA (thead)
      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      const labels = ["Fecha", "Sesi√≥n", ...classes];
      labels.forEach(text => {
        const th = document.createElement("th");
        th.textContent = text;
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      calendarTable.appendChild(thead);

      // CUERPO (tbody)
      const tbody = document.createElement("tbody");

      days.forEach(day => {
        slotsForMonth.forEach((slot, slotIndex) => {
          const tr = document.createElement("tr");

          // Primera franja del d√≠a ‚Üí separador grueso
          if (slotIndex === 0) {
            tr.classList.add("first-slot-of-day");
          }

          const tdFecha = document.createElement("td");
          tdFecha.textContent = day.label;
          tr.appendChild(tdFecha);

          const tdSlot = document.createElement("td");
          tdSlot.textContent = slot;
          tr.appendChild(tdSlot);

          // Para saber si esta franja (fila) tiene alguna reserva
          let rowHasReservation = false;

          classes.forEach(cls => {
            const td = document.createElement("td");
            td.classList.add("reservable");
            td.dataset.date = day.iso;
            td.dataset.slot = slot;
            td.dataset.class = cls; // usado para la marca de agua

            const id = buildReservationId(day.iso, slot, cls);
            const isFixed = isFixedReservation(day.iso, slot, cls);

            if (isFixed) {
              // reserva fija del horario ‚Üí siempre ocupada y no clicable
              td.classList.add("fixed-reserved");
              td.dataset.fixed = "true";
              rowHasReservation = true;
            } else if (saved[id]) {
              td.classList.add("reserved");
              rowHasReservation = true;
            }

            tr.appendChild(td);
          });

          // Si alguna celda de esta franja est√° reservada, coloreamos toda la fila
          if (rowHasReservation) {
            tr.classList.add("row-has-reservation");
          }

          tbody.appendChild(tr);
        });
      });

      calendarTable.appendChild(tbody);
    }

    // üß† L√ìGICA DE RESERVA / LIBERACI√ìN CON DOBLE CLIC / DOBLE TOQUE
    const DOUBLE_CLICK_MS = 400;
    let lastCellId = null;
    let lastClickTime = 0;

    async function activarCelda(cell) {
      // Si es una reserva fija del horario, no hacemos nada
      if (cell.dataset.fixed === "true") {
        alert("Esta franja horaria est√° reservada de forma fija en el horario y no se puede modificar.");
        return;
      }

      const { date, slot, class: className } = cell.dataset;
      const id = buildReservationId(date, slot, className);
      const fullId = buildFullReservationId(id);

      const value = currentData[id];   // puede ser undefined, true o timestamp (number)
      const now   = Date.now();

      // Si NO hay reserva en esta celda ‚Üí queremos crear una nueva
      if (!value) {
        // 1) Comprobar si el usuario YA tiene una reserva activa
        // en esta MISMA semana (ISO) en las √∫ltimas 24h
        const weekKey = getWeekKeyFromIso(date);
        let userInfo = getUserReservationInfoForWeek(weekKey);

        if (userInfo) {
          // Desglosamos la reserva guardada: docId::resId
          const [docId, resId] = userInfo.fullId.split("::");

          // Si la reserva guardada corresponde al documento (mes) actual,
          // comprobamos si REALMENTE sigue existiendo en Firestore
          if (docId === getCurrentDocId()) {
            const stillExists = currentData && currentData[resId];

            // Si ya no existe (alguien se la ha quitado), borramos la marca local de esa semana
            if (!stillExists) {
              removeUserReservationByFullId(userInfo.fullId);
              userInfo = null; // como si no tuviera reserva esa semana
            }
          }
        }

        if (userInfo) {
          // Aqu√≠ solo llegamos si la reserva guardada para esa semana sigue activa
          alert("Ya tienes una reserva activa esta semana en las √∫ltimas 24 horas.");
          return;
        }

        // 2) Comprobar si la franja ya est√° ocupada por otra clase o por una reserva fija
        const existing = getExistingReservationForSlot(date, slot);
        if (existing) {
          const reservedClass = existing.className || "otra clase";
          alert(`No puedes reservar esta franja horaria porque ya est√° reservada por ${reservedClass}.`);
          return;
        }

        // 3) La franja est√° libre ‚Üí crear reserva con timestamp (ms)
        await setReservationValue(id, now);

        // guardar la reserva del usuario en localStorage para ESA semana
        const newWeekKey = getWeekKeyFromIso(date);
        addUserReservationForWeek(newWeekKey, fullId, now);
        return;
      }

      // Si es un n√∫mero, es un timestamp ‚Üí comprobamos ventana de tiempo para DESHACER
      if (typeof value === "number") {
        const elapsed = now - value;
        if (elapsed <= UNRESERVE_WINDOW_MS) {
          await clearReservation(id);
          // si esta reserva era alguna de las guardadas del usuario, la eliminamos del mapa
          removeUserReservationByFullId(fullId);
        } else {
          alert("Esta reserva ya no se puede modificar.");
        }
        return;
      }

      // Compatibilidad con reservas antiguas (valor true): se permite borrar siempre
      if (value === true) {
        await clearReservation(id);
        removeUserReservationByFullId(fullId);
        return;
      }
    }

    calendarTable.addEventListener("click", (event) => {
      const cell = event.target.closest("td.reservable");
      if (!cell) return;

      const uniqueId = `${cell.dataset.date}__${cell.dataset.slot}__${cell.dataset.class}`;
      const now = Date.now();

      if (lastCellId === uniqueId && (now - lastClickTime) <= DOUBLE_CLICK_MS) {
        // Doble clic / doble toque ‚Üí activar
        activarCelda(cell);
        lastCellId = null;
        lastClickTime = 0;
      } else {
        // Primer clic ‚Üí solo marcar el tiempo
        lastCellId = uniqueId;
        lastClickTime = now;
      }
    });

    // Inicializar
    monthSelect.value = "0";
    subscribeToMonth(0);
  </script>
</body>
</html>
